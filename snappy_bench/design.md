# 디자인: Rust-C FFI + Wasm 멀티 메모리 격리 벤치마크 (Snappy)

## 목표

* C 코드를 별도의 Wasm 메모리 인스턴스에 격리했을 때의 오버헤드를 정량화한다.
* 순수 FFI 비용과 크로스-메모리 복사 비용을 분리해 측정한다.
* 벤치마크 범위를 `snappy_compress` 와 `snappy_uncompress`에 집중한다.

## 비목표

* Snappy 자체를 튜닝하거나 다른 코덱과 비교하는 것.
* 전체 애플리케이션 파이프라인이나 I/O를 측정하는 것.

## 정의

* **mem0**: Rust 측 메모리(호출자 측).
* **mem1**: C 측 Wasm 메모리(격리 대상).
* **Baseline**: 공유 메모리(격리 없음)에서 Rust->C FFI 호출.
* **Isolated**: C가 mem1만 볼 수 있도록 한 Rust->C FFI 호출.

## 벤치마크 경로

1. **Baseline (공유 메모리)**
   Rust가 mem0에 입력/출력을 할당하고 C를 직접 호출한다.

2. **Isolated (mem0 <-> mem1)**
   Rust가 입력을 mem0에서 mem1으로 복사한 뒤, mem1 버퍼를 대상으로 C를 호출하고, 그 다음 출력을 mem1에서 mem0으로 다시 복사한다.

3. **복사만 제어군(Copy-only control)**
   동일한 크기들로 mem0->mem1->mem0 memcpy/memmove 비용을 측정하여 복사 오버헤드를 분리한다.

격리 오버헤드는 다음과 같이 계산한다:
`isolated_time - baseline_time - copy_time`

## 테스트 대상 함수

* `snappy_compress`
* `snappy_uncompress`

## 데이터 이동 상세

* 입력 버퍼는 mem0에 존재한다.
* 격리를 위해 mem1에 입력/출력 버퍼를 할당한다.
* C 호출 전에 입력을 mem1으로 복사한다.
* 호출 후, 출력(압축 결과 또는 압축 해제 결과)을 mem0으로 복사해온다.
* 압축의 경우 `snappy_max_compressed_length`를 사용해 mem1 출력 크기를 잡는다.
* 압축 해제의 경우, 알려진 원본(비압축) 길이를 사용해 mem1 출력 크기를 잡는다.

## 메트릭

* 호출당 지연시간(ns/us)
* 처리량(MB/s)
* 파생 격리 오버헤드(위 공식으로 계산)

## 입력

* 여러 크기: 소(<=1 KiB), 중(16-64 KiB), 대(>=1 MiB)
* 압축이 잘 되는 데이터셋 1개 이상과, 압축이 잘 안 되는(비압축성) 데이터셋 1개 이상 포함
* 재현 가능한 실행을 위해 합성 데이터는 고정 시드(fixed seed)를 사용한다

## 제어 조건

* 모든 변형에서 동일한 컴파일러 플래그 사용(예: `-O3`).
* 측정 전에 워밍업 반복을 수행한다.
* 크기별 고정 반복 횟수를 사용한다.
* 안정적인 타이밍 소스(단조 증가/모노토닉 클록)를 사용한다.

## 검증

* 압축 해제 결과가 원본 입력과 동일함을 검증한다.
* 압축의 경우, 데이터셋당 한 번씩 선택적으로 라운드트립 정확성을 검증한다.

## 리포팅

* 크기별 표: baseline, isolated, copy-only, overhead
* 복사 비용이 지배적인 크기 구간을 강조한다
* 환경 노트(CPU 모델, 빌드 플래그)를 포함한다

## 미해결 질문

* 런타임에서 mem0/mem1 할당 API의 정확한 형태
* 더 안정적인 수치를 위해 CPU affinity를 고정(pinning)할지 여부
